//generate_scad_scaffolding
#include <iostream>
#include <fstream>
#include "bridge.h"
#include "get_points/point.h"
using std::ofstream;
using std::cout;
using std::endl;
using std::string;

//for testing (from test_generate_scaffolding)
set<Point> active_points; //this is what is sent from algorithm 1: GetPoints
//void make_point_set()
//{
	//Point p0(1, 1, 1);
	Point p1(19, 9, 15);
	Point p2(11, 15, 20);
	Point p3(25, 20, 18);
	Point p4(18, 24, 17);
	//active_points.insert(p0);
void make_point_set()
{
	active_points.insert(p1);
	active_points.insert(p2);
	active_points.insert(p3);
	active_points.insert(p4);
}

set<Bridge> active_bridges;//this should be produced by algorithm 3...
//Point _p1, Point _p2, double _length, double _height, bool _pt1_open, bool _pt2_open
void make_bridge_set()
{
	Bridge b1(p1, p2, 5, 5, false, false);
	Bridge b2(p2, p3, 6, 6, false, false);
	Bridge b3(p3, p4, 10, 10, false, false);
	active_bridges.insert(b1);
	active_bridges.insert(b2);
	active_bridges.insert(b3);
}

void insert_header_info(ofstream &filename)
{
	cout << "inserting header info" << endl;
	filename << "//scad pillars and bars generated by code" << endl << endl;
	filename << "$fa = 50;" << endl;
	filename << "$fn = 50;" << endl;
	filename << "radius = 1;" << endl;
	filename << "delta = 2;" << endl;
	filename << "height = 0.4;" << endl << endl;
	filename << "module pillar(x_coord, y_coord, z_coord, z_height)" << endl;
	filename << "{" << endl;
    filename << "\ttranslate([x_coord, y_coord, z_coord])" << endl;
    filename << "\tlinear_extrude(z_height)" << endl;
    filename << "\tcircle(radius);" << endl;
	filename << "}" << endl << endl;
	filename << "//does not work for horizontal bridges, use bridge1" << endl;
	filename << "module bridge(x0, y0, x1, y1, z_height)" << endl;
	filename << "{" << endl;
    filename << "translate([0, 0, z_height])" << endl;
    filename << "linear_extrude(height)" << endl;
    filename << "polygon(points = [[x0+delta, y0], [x0-delta, y0], [x1-delta, y1], [x1+delta, y1]]);" << endl;
	filename << "}" << endl << endl;
	filename << "//does not work for vertical bridges, use bridge" << endl;
	filename << "module bridge1(x0, y0, x1, y1, z_height)" << endl;
	filename << "{" << endl;
    filename << "translate([0, 0, z_height])" << endl;
    filename << "linear_extrude(height)" << endl;
    filename << "polygon(points = [[x0, y0+delta], [x0, y0-delta], [x1, y1-delta], [x1, y1+delta]]);" << endl;
	filename << "}" << endl << endl;
	filename << "union()" << endl;
	filename << "{" << endl; //union opening brace
}

void sending_test_structures(ofstream & filename)
{
	filename << "\tbridge(0, 0, 25, 20, 10);" << endl;
	filename << "\tbridge(0, 0, 0, 10, 5);" << endl;
	filename << "\tbridge1(0, 0, 25, 20, 10);" << endl;
	filename << "\tbridge1(0, 0, 10, 0, 5);" << endl;
	filename << "\tpillar(10, 10, 10, 10);" << endl;
}

void send_points(ofstream & filename, set<Point> &point_set)
{
	for(auto i = point_set.begin(); i != point_set.end(); i++)
	{
		filename << "//adding point" << endl;
		//pillar in format (x, y, z-base of pillar, total height of pillar from base to top)
		//pillar z-base is 0 for any points that are not associated with a bridge at the end
		//of the scaffolding generation
		filename << "\tpillar(" << i->x << ", " << i->y << ", 0, " << i->z <<");" << endl;
	}
}

//will need to work in conditional for horizontal bridges, if horizontal, use bridge1
//otherwise use bridge
void send_bridges(ofstream & filename, set<Bridge> bridge_set)
{
	for(auto i = bridge_set.begin(); i != bridge_set.end(); i++)
	{
		filename << "//adding bridge" << endl;
		filename << "\tbridge(" << i->p1.x << ", " << i->p1.y << ", " << i->p2.x << ", " << i->p2.y << ", " << i->height << ");" << endl;
	}
}

void insert_closing_brace(ofstream & filename)
{
	filename << "}" << endl << endl; //union closing brace
}

int main()
{
	make_point_set();
	make_bridge_set();
	ofstream out_file("scad_output.scad");
	insert_header_info(out_file);
	//sending_test_structures(out_file);
	send_points(out_file, active_points);
	send_bridges(out_file, active_bridges);
	insert_closing_brace(out_file);

	return 0;
}