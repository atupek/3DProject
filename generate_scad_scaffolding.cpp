//generate_scad_scaffolding
#include <iostream>
#include <fstream>
#include "bridge.h"
#include "get_points/point.h"
#include <vector>
using std::ofstream;
using std::cout;
using std::endl;
using std::string;
using std::vector;

//for testing (from test_generate_scaffolding)
set<Point> active_points; //this is what is sent from algorithm 1: GetPoints

Point p1(19, 9, 15);
Point p2(11, 15, 20);
Point p3(25, 20, 18);
Point p4(18, 24, 17);

vector<Point> pts_for_pillars;

Point p5(19, 13, 17);
Point p6(19, 9, 15);
Point p7(13, 15, 22);
Point p8(11, 15, 20);
Point p9(18, 20, 20);
Point p10(18, 24, 17);

void make_pillar_pt_vec()
{
	pts_for_pillars.push_back(p5);
	pts_for_pillars.push_back(p6);
	pts_for_pillars.push_back(p7);
	pts_for_pillars.push_back(p8);
	pts_for_pillars.push_back(p9);
	pts_for_pillars.push_back(p10);
}

void make_point_set()
{
	active_points.insert(p1);
	active_points.insert(p2);
	active_points.insert(p3);
	active_points.insert(p4);
}

set<Bridge> active_bridges;//this should be produced by algorithm 3...
//Point _p1, Point _p2, double _length, double _height, bool _pt1_open, bool _pt2_open
void make_bridge_set()
{
	Bridge b1(p1, p2, 5, 5, false, false);
	Bridge b2(p2, p3, 6, 6, false, false);
	Bridge b3(p3, p4, 10, 10, false, false);
	active_bridges.insert(b1);
	active_bridges.insert(b2);
	active_bridges.insert(b3);
}

void insert_header_info(ofstream &filename)
{
	cout << "inserting header info" << endl;
	filename << "//scad pillars and bars generated by code" << endl << endl;
	filename << "$fa = 50;" << endl;
	filename << "$fn = 50;" << endl;
	filename << "radius = 1;" << endl;
	filename << "delta = 2;" << endl;
	filename << "height = 0.4;" << endl << endl;

	filename << "module circle1(x_coord, y_coord, z_coord)" << endl;
	filename << "{" << endl;
    filename << "\ttranslate([x_coord, y_coord, z_coord])" << endl;
    filename << "\tcylinder(.2, radius, radius);" << endl;
	filename << "}" << endl;

	filename << "module circle2(x_coord, y_coord, z_coord)" << endl;
	filename << "{" << endl;
    filename << "\ttranslate([x_coord, y_coord, z_coord])" << endl;
    filename << "\tcylinder(.2, radius, radius);" << endl;
	filename << "}" << endl;

	filename << "module slanted_pillar(x_coord1, y_coord1, z_coord1, x_coord2, y_coord2, z_coord2)" << endl;
	filename << "{" << endl;
    filename << "\thull()" << endl;
    filename << "\t{" << endl;
    filename << "\t\tcircle1(x_coord1, y_coord1, z_coord1);" << endl;
    filename << "\t\tcircle2(x_coord2, y_coord2, z_coord2);" << endl;
    filename << "\t}" << endl;
	filename << "}" << endl;


	filename << "module pillar(x_coord, y_coord, z_coord, z_height)" << endl;
	filename << "{" << endl;
    filename << "\ttranslate([x_coord, y_coord, z_coord])" << endl;
    filename << "\tlinear_extrude(z_height)" << endl;
    filename << "\tcircle(radius);" << endl;
	filename << "}" << endl << endl;
	filename << "//does not work for horizontal bridges, use bridge1" << endl;
	filename << "module bridge(x0, y0, x1, y1, z_height)" << endl;
	filename << "{" << endl;
    filename << "translate([0, 0, z_height])" << endl;
    filename << "linear_extrude(height)" << endl;
    filename << "polygon(points = [[x0+delta, y0], [x0-delta, y0], [x1-delta, y1], [x1+delta, y1]]);" << endl;
	filename << "}" << endl << endl;
	filename << "//does not work for vertical bridges, use bridge" << endl;
	filename << "module bridge1(x0, y0, x1, y1, z_height)" << endl;
	filename << "{" << endl;
    filename << "translate([0, 0, z_height])" << endl;
    filename << "linear_extrude(height)" << endl;
    filename << "polygon(points = [[x0, y0+delta], [x0, y0-delta], [x1, y1-delta], [x1, y1+delta]]);" << endl;
	filename << "}" << endl << endl;
	filename << "union()" << endl;
	filename << "{" << endl; //union opening brace
}

void sending_test_structures(ofstream & filename)
{
	filename << "\tbridge(0, 0, 25, 20, 10);" << endl;
	filename << "\tbridge(0, 0, 0, 10, 5);" << endl;
	filename << "\tbridge1(0, 0, 25, 20, 10);" << endl;
	filename << "\tbridge1(0, 0, 10, 0, 5);" << endl;
	filename << "\tpillar(10, 10, 10, 10);" << endl;
}

void send_slanted_pillars(ofstream & filename, vector<Point> &pts_for_pillars)
{
	for(int i = 0; i < pts_for_pillars.size()-1; i+=2)
	{
		filename << "//adding slanted pillar" << endl;
		filename << "\tslanted_pillar(" << pts_for_pillars[i].x << ", " << pts_for_pillars[i].y << ", " << pts_for_pillars[i].z << ", "
										<< pts_for_pillars[i+1].x << ", " << pts_for_pillars[i+1].y << ", " << pts_for_pillars[i+1].z << ");" << endl;
	}
}

void send_points(ofstream & filename, set<Point> &point_set)
{
	for(auto i = point_set.begin(); i != point_set.end(); i++)
	{
		filename << "//adding point" << endl;
		//pillar in format (x, y, z-base of pillar, total height of pillar from base to top)
		//pillar z-base is 0 for any points that are not associated with a bridge at the end
		//of the scaffolding generation
		filename << "\tpillar(" << i->x << ", " << i->y << ", 0, " << i->z <<");" << endl;
	}
}

//TODO: NEED TO TEST THIS...
//will need to work in conditional for horizontal bridges, if horizontal (p1.y == p2.y), use bridge1
//otherwise use bridge
void send_bridges(ofstream & filename, set<Bridge> bridge_set)
{
	for(auto i = bridge_set.begin(); i != bridge_set.end(); i++)
	{
		if(i->p1.y == i->p2.y)
		{
			filename << "//adding bridge" << endl;
			filename << "\tbridge1(" << i->p1.x << ", " << i->p1.y << ", " << i->p2.x << ", " << i->p2.y << ", " << i->height << ");" << endl;
			filename << "\tpillar(" << i->p1.x << ", " << i->p1.y << ", " << i->height << ", " << (i->height - i->p1.z) << ");" << endl;
			filename << "\tpillar(" << i->p2.x << ", " << i->p2.y << ", " << i->height << ", " << (i->height - i->p2.z) << ");" << endl;
		}
		else
		{
			filename << "//adding bridge" << endl;
			filename << "\tbridge(" << i->p1.x << ", " << i->p1.y << ", " << i->p2.x << ", " << i->p2.y << ", " << i->height << ");" << endl;
			filename << "\tpillar(" << i->p1.x << ", " << i->p1.y << ", " << i->height << ", " << (i->p1.z - i->height) << ");" << endl;
			filename << "\tpillar(" << i->p2.x << ", " << i->p2.y << ", " << i->height << ", " << (i->p2.z - i->height) << ");" << endl;
		}
	}
}

void insert_closing_brace(ofstream & filename)
{
	filename << "}" << endl << endl; //union closing brace
}

int main()
{
	make_point_set();
	make_bridge_set();
	make_pillar_pt_vec();
	ofstream out_file("scad_output.scad");
	insert_header_info(out_file);
	//sending_test_structures(out_file);
	send_slanted_pillars(out_file, pts_for_pillars);
	send_points(out_file, active_points);
	send_bridges(out_file, active_bridges);
	insert_closing_brace(out_file);

	return 0;
}